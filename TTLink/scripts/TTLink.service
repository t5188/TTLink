#!/system/bin/sh
cd ${0%/*} # current working directory
source ./settings.ini

disable_ipv6() {
  echo 0 >/proc/sys/net/ipv6/conf/all/accept_ra
  echo 0 >/proc/sys/net/ipv6/conf/wlan0/accept_ra
  echo 1 >/proc/sys/net/ipv6/conf/all/disable_ipv6
  echo 1 >/proc/sys/net/ipv6/conf/default/disable_ipv6
  echo 1 >/proc/sys/net/ipv6/conf/wlan0/disable_ipv6
}

enable_ipv6() {
  echo 1 >/proc/sys/net/ipv6/conf/all/accept_ra
  echo 1 >/proc/sys/net/ipv6/conf/wlan0/accept_ra
  echo 0 >/proc/sys/net/ipv6/conf/all/disable_ipv6
  echo 0 >/proc/sys/net/ipv6/conf/default/disable_ipv6
  echo 0 >/proc/sys/net/ipv6/conf/wlan0/disable_ipv6
}

device_index() {
  local max_retries=10
  local retry_count=0
  index=""
  if [ ! -f "./tables.tmp" ]; then
    device=$(awk -F'"' '/"interface_name"/ {print $4; exit}' ${box_confs_dir}/*.json)
    while [ -z "$index" ] && [ $retry_count -lt $max_retries ]; do
      index=$(ip route show table all | grep -E "default dev ${device} table [0-9]" | head -n 1 | awk '{print $5}')
      if [ -n "$index" ]; then
        break
      fi
      sleep 2
      retry_count=$((retry_count + 1))
      log Info "Attempting to fetch index (Attempt ${retry_count}/${max_retries})" >>"../log/run.log"
    done
    [[ -n "${index}" ]] && echo "${index} ${device}" >./tables.tmp
    [[ -z "${index}" ]] && log Error "Failed to fetch index" >>"../log/run.log" && exit 1
  fi
  read index device <"./tables.tmp"
}

ip_rules() {
  device_index
  local action=$1
  ipv4_rules=(
    "iif lo goto 6000 priority 5000"
    "iif ${device} lookup main suppress_prefixlength 0 priority 5010"
    "iif ${device} goto 6000 priority 5020"
    "from 10.0.0.0/8 lookup ${index} priority 5030"
    "from 172.16.0.0/12 lookup ${index} priority 5040"
    "from 192.168.0.0/16 lookup ${index} priority 5050"
    "nop priority 6000"
    "lookup main priority 7000"
  )
  for rule in "${ipv4_rules[@]}"; do
    ip -4 rule "${action}" ${rule}
  done
  case "${action}" in
  "add" | "-A" | "-I")
    log Info "IPv4 rules have been created" >>"../log/run.log"
    ;;
  "del" | "-D")
    log Info "IPv4 rules have been removed" >>"../log/run.log"
    ;;
  esac
  ipv6_rules=(
    "iif lo goto 6000 priority 5000"
    "iif ${device} lookup main suppress_prefixlength 0 priority 5010"
    "iif ${device} goto 6000 priority 5020"
    #"from 2001:db8::/32 lookup ${index} priority 5030"
    #"from fc00::/7 lookup ${index} priority 5040"
    #"from fd00::/8 lookup ${index} priority 5050"
    "nop priority 6000"
    "lookup main priority 7000"
  )
  for rule in "${ipv6_rules[@]}"; do
    ip -6 rule "${action}" ${rule}
  done
  case "${action}" in
  "add" | "-A" | "-I")
    log Info "IPv6 rules have been created" >>"../log/run.log"
    ;;
  "del" | "-D")
    log Info "IPv6 rules have been removed" >>"../log/run.log"
    ;;
  esac
}

ipt_tun() {
  local iptables=$1
  local action=$2
  if [[ "${action}" == "-I" ]]; then
    ${iptables} -N TUN_FORWARD 2>/dev/null
    ${iptables} -F TUN_FORWARD 2>/dev/null
    ${iptables} "${action}" TUN_FORWARD -i "${device}" -j ACCEPT
    ${iptables} "${action}" TUN_FORWARD -o "${device}" -j ACCEPT
    ${iptables} "${action}" FORWARD -j TUN_FORWARD
  elif [[ "${action}" == "-D" ]]; then
    ${iptables} "${action}" FORWARD -j TUN_FORWARD
    ${iptables} -F TUN_FORWARD 2>/dev/null
    ${iptables} -X TUN_FORWARD 2>/dev/null
  fi
  case "${action}" in
  "add" | "-A" | "-I")
    log Info "${iptables} TUN_FORWARD chain has been created" >>"../log/run.log"
    ;;
  "del" | "-D")
    log Info "${iptables} TUN_FORWARD chain has been removed" >>"../log/run.log"
    ;;
  esac
  ${iptables} "${action}" OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${iptables} "${action}" OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${iptables} "${action}" OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
  ${iptables} "${action}" OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
  case "${action}" in
  "add" | "-A" | "-I")
    log Info "${iptables} QUIC has been created" >>"../log/run.log"
    ;;
  "del" | "-D")
    log Info "${iptables} QUIC has been removed" >>"../log/run.log"
    ;;
  esac
}

dns_tun() {
  local name="DNS2TUN"
  local ip=${1}
  local iptables=${2}
  local action=${3}
  if [[ "${network_mode}" == "tun" ]]; then
    if [[ "${action}" == "-A" ]]; then
      local action1="add"
    elif [[ "${action}" == "-D" ]]; then
      local action1="del"
    fi
    ${ip} rule ${action1} fwmark 53 table ${index} priority 1000
    ${ip} route ${action1} default dev ${device} table ${index}
    case "${action1}" in
    "add" | "-A" | "-I")
      log Info "${ip} DNS2TUN rule has been created" >>"../log/run.log"
      ;;
    "del" | "-D")
      log Info "${ip} DNS2TUN rule has been removed" >>"../log/run.log"
      ;;
    esac
    if [[ "${action}" != "-D" ]]; then
      ${iptables} -t mangle -N ${name}
      ${iptables} -t mangle -F ${name}
      ${iptables} -t mangle ${action} ${name} -p udp --dport 53 -j MARK --set-mark 53
      ${iptables} -t mangle ${action} ${name} -p tcp --dport 53 -j MARK --set-mark 53
      case "${action1}" in
      "add" | "-A" | "-I")
        log Info "${iptables} ${name} rule has been created" >>"../log/run.log"
        ;;
      esac
    fi
    ${iptables} -t mangle ${action} OUTPUT -j ${name}
    ${iptables} -t mangle ${action} PREROUTING -j ${name}
    if [[ "${action}" == "-D" ]]; then
      ${iptables} -t mangle -F ${name}
      ${iptables} -t mangle -X ${name}
      log Info "${iptables} ${name} rule has been removed" >>"../log/run.log"
    fi
  else
    return
  fi
}

exec_dns_tun() {
  dns_tun "ip -4" "iptables" "-A"
  dns_tun "ip -6" "ip6tables" "-A"
}

rm_dns_tun() {
  dns_tun "ip -4" "iptables" "-D"
  dns_tun "ip -6" "ip6tables" "-D"
}

forward() {
  local action=$1
  if [[ "${action}" == "-I" ]]; then
    echo 1 >/proc/sys/net/ipv4/ip_forward
    echo 2 >/proc/sys/net/ipv4/conf/default/rp_filter
    echo 2 >/proc/sys/net/ipv4/conf/all/rp_filter
    enable_ipv6
    ip_rules "add"
    log Info "IP forwarding has been enabled" >>"../log/run.log"
  elif [[ "${action}" == "-D" ]]; then
    # disable_ipv6
    ip_rules "del"
    log Info "IP forwarding has been disabled" >>"../log/run.log"
  fi
  ipt_tun "iptables" "${action}"
  ipt_tun "ip6tables" "${action}"
}

init_uids() {
  uid=""
  uids=()
  if [ -f "../log/uids.list" ]; then
    rm "../log/uids.list"
  fi

  for package_name in "${package_list[@]}"; do
    uid=$(busybox awk -v package="${package_name}" '$1 == package {print $2}' /data/system/packages.list)
    if [ -n "${uid}" ]; then
      uids+=("${uid}")
      echo "${package_name}: ${uid}" >>"../log/uids.list"
    fi
  done

  for package_name in "${appclones[@]}"; do
    uid=$(busybox awk -v package="${package_name}" '$1 == package {print $2}' /data/system/packages.list)
    if [ -n "${uid}" ]; then
      uid="999$uid"
      uids+=("${uid}")
      echo "${package_name}: ${uid}" >>"../log/uids.list"
    fi
  done

  sort -t ':' -k2 -n "../log/uids.list" -o "../log/uids.list"
  uids=($(printf "%s\n" "${uids[@]}" | sort -n | uniq))
}

init_uidrange() {
  init_uids
  start=0
  end=99999999
  previous=$start
  for uid in "${uids[@]}"; do
    if [[ $((uid - 1)) -ge $previous ]]; then
      echo "${previous}-$((uid - 1))"
    fi
    previous=$((uid + 1))
  done
  if [[ $previous -le $end ]]; then
    echo "${previous}-${end}"
  fi
}

uidrange() {
  local action=${1}
  stdout2array=()

  if [[ "${proxy_mode}" == "whitelist" ]] && [[ ${#package_list[@]} -gt 0 ]]; then
    stdout2array=($(init_uidrange))
    for whiteapp in "${stdout2array[@]}"; do
      ip -4 rule ${action} from all uidrange ${whiteapp} priority 9000 goto 9010
      ip -6 rule ${action} from all uidrange ${whiteapp} priority 9000 goto 9010
    done

  elif [[ "${proxy_mode}" == "blacklist" ]] && [[ ${#package_list[@]} -gt 0 ]]; then
    init_uids
    uids+=("${box_user}" "${xray_user}")
    uids=($(printf "%s\n" "${uids[@]}" | sort -n | uniq))
    for blackapp in "${uids[@]}"; do
      ip -4 rule ${action} from all uidrange ${blackapp}-${blackapp} priority 9000 goto 9010
      ip -6 rule ${action} from all uidrange ${blackapp}-${blackapp} priority 9000 goto 9010
    done

  elif [[ ${#package_list[@]} -eq 0 ]]; then
    uids=("${box_user}" "${xray_user}")
    for users in "${uids[@]}"; do
      ip -4 rule ${action} from all uidrange ${users}-${users} priority 9000 goto 9010
      ip -6 rule ${action} from all uidrange ${users}-${users} priority 9000 goto 9010
    done

  else
    return
  fi

  case "${action}" in
  "add" | "-A" | "-I")
    log Info "Package rules have been created" >>"../log/run.log"
    log Info "proxy_mode: ${proxy_mode}" >>"../log/run.log"
    ;;
  "del" | "-D")
    log Info "Package rules have been removed" >>"../log/run.log"
    ;;
  esac
}

add_trp() {
# Policy routing: fwmark -> table ${table}, then redirect to local (lo) for TPROXY
  ${1} rule add fwmark "${fwmark}" table ${table} priority 1000
  ${1} route add local default dev lo table ${table}
# Initialize custom chains (EXTERNAL, LOCAL)
  ${2} -t mangle -N ${3}_EXTERNAL
  ${2} -t mangle -F ${3}_EXTERNAL
  ${2} -t mangle -N ${3}_LOCAL
  ${2} -t mangle -F ${3}_LOCAL
  ${2} -t mangle -N ${3}_BLOCK_LOOPBACK
  ${2} -t mangle -F ${3}_BLOCK_LOOPBACK
# Exclude Xray process traffic (prevent proxy loop)
  ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${box_user} --gid-owner ${box_group} -j RETURN
  ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${xray_user} --gid-owner ${xray_group} -j RETURN
  for proto in udp tcp; do
    # Mark local DNS (53) traffic for proxy routing
    ${2} -t mangle -A ${3}_LOCAL -p ${proto} --dport 53 -j MARK --set-xmark ${fwmark}
    # Redirect external DNS (53) traffic to TPROXY port with mark
    ${2} -t mangle -A ${3}_EXTERNAL -p ${proto} --dport 53 -j TPROXY --on-port ${tp_port} --tproxy-mark ${fwmark}
  done
# Bypass specified subnets (do not route them into proxy)
  ${2} -t mangle -A ${3}_EXTERNAL -j ${3}_BLOCK_LOOPBACK
  ${2} -t mangle -A ${3}_LOCAL -j ${3}_BLOCK_LOOPBACK
  for subnet in ${4}; do
    ${2} -t mangle -A ${3}_EXTERNAL -d ${subnet} -j RETURN
    ${2} -t mangle -A ${3}_LOCAL -d ${subnet} -j RETURN
  done
# Route traffic into the tproxy
  for proto in udp tcp; do
    ${2} -t mangle -A ${3}_EXTERNAL -p ${proto} -j TPROXY --on-port "${tp_port}" --tproxy-mark "${fwmark}"
  done
# Mark traffic from specified system UIDs for proxy routing
  if [[ -n "${AIDs}" ]]; then
    for AID in ${AIDs[@]}; do
      ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${AID} -p tcp -j MARK --set-xmark ${fwmark}
      ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${AID} -p udp -j MARK --set-xmark ${fwmark}
    done
  fi
# Blacklist mode: exclude specified UIDs (except DNS), all others go through proxy
# Whitelist mode: only specified UIDs go through proxy, if none specified then all
  case "${proxy_mode}" in
  "blacklist")
    if [[ ${#uids[@]} -gt 0 ]]; then
      for appid in ${uids[*]}; do
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p tcp ! --dport 53 -j RETURN
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p udp ! --dport 53 -j RETURN
      done
      ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    else
      ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    fi
    ;;
  "whitelist")
    if [[ ${#uids[@]} -gt 0 ]]; then
      for appid in ${uids[*]}; do
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p tcp -j MARK --set-xmark ${fwmark}
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p udp -j MARK --set-xmark ${fwmark}
      done
    else
      ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    fi
    ;;
  *)
    ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    toast "GLOBAL PROXY, CHECK PROXY_MODE"
    ;;
  esac
# Attach custom chains: EXTERNAL -> PREROUTING, LOCAL -> OUTPUT
  ${2} -t mangle -A PREROUTING -j ${3}_EXTERNAL
  ${2} -t mangle -A OUTPUT -j ${3}_LOCAL
}

del_trp() {
  ${1} rule del fwmark "${fwmark}" table ${table} priority 1000
  ${1} route del local default dev lo table ${table}
  ${1} route flush table ${table}
  ${2} -t mangle -D PREROUTING -j ${3}_EXTERNAL
  ${2} -t mangle -D OUTPUT -j ${3}_LOCAL
  ${2} -t mangle -F ${3}_EXTERNAL
  ${2} -t mangle -F ${3}_LOCAL
  ${2} -t mangle -F ${3}_BLOCK_LOOPBACK
  ${2} -t mangle -X ${3}_EXTERNAL
  ${2} -t mangle -X ${3}_LOCAL
  ${2} -t mangle -X ${3}_BLOCK_LOOPBACK
}

run_add_trp() {
  log Info "tp_port: ${tp_port}" >>"../log/run.log"
  add_trp "ip -4" "${IPV}" "${chain_name}4" "${intranet4[*]}"
  add_trp "ip -6" "${IP6V}" "${chain_name}6" "${intranet6[*]}"
}

run_del_trp() {
  del_trp "ip -4" "${IPV}" "${chain_name}4"
  del_trp "ip -6" "${IP6V}" "${chain_name}6"
}

add_cron() {
  if [[ "${crond_task}" == "enable" ]]; then
    crontab_file="./root"
    if pgrep busybox crond >/dev/null; then
      kill -9 $(pgrep busybox crond)
    fi
    echo "5 0,12 * * * touch ${module_dir}/disable && sleep 3 && rm ${module_dir}/disable" > "${crontab_file}"
    nohup busybox crond -c ./ >/dev/null 2>&1 &
    log Info "New task: $(busybox crontab -l -c ./)" >>"../log/run.log"
  else
    log Warn "crond_task is not set to enable. No crond task created." >>"../log/run.log"
  fi
}

del_cron() {
  if pgrep busybox crond >/dev/null; then
    kill -9 $(pgrep busybox crond)
    rm ./root >/dev/null 2>&1
  fi
}

disable_quic() {
  ${1} ${2} OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${1} ${2} OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${1} ${2} OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
  ${1} ${2} OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
}

run_disable_quic() {
  if [[ "${quic}" == "disable" ]]; then
    disable_quic "${IPV}" "-I"
    disable_quic "${IP6V}" "-I"
  fi
}

del_disable_quic() {
  if [[ "${quic}" == "disable" ]]; then
    disable_quic "${IPV}" "-D"
    disable_quic "${IP6V}" "-D"
  fi
}

version() {
  version_box=$(${bin_box} version | head -n 1 | awk '{print $3}')
  version_xray=$(${bin_xray} version | head -n 1 | awk '{print $2}')
}

ownership() {
  chmod 755 ${bin_box} ${bin_xray}
  chown root:net_admin ${bin_box} ${bin_xray}
  chmod o+rw ${public_log_dir}
  find ".." -type f -name "*.log" ! -name "run.log" -exec rm -f {} + 2>/dev/null
  log Info "Ownership has been set" >>"../log/run.log"
}

launch_cores() {
  ulimit -SHn 1000000
  ownership
  if [[ -f "${bin_box}" && -f "${bin_xray}" ]]; then
    nohup busybox setuidgid ${box_user}:${box_group} ${bin_box} run -C ${box_confs_dir} -D ../binary/ >/dev/null 2>&1 &
    if [[ "${network_mode}" == "tun" ]]; then
      forward -I
      uidrange add
      [[ "${dns2tun}" == "enable" ]] && exec_dns_tun
    fi
    nohup busybox setuidgid ${xray_user}:${xray_group} ${bin_xray} run -confdir ${xray_confx_dir} >/dev/null 2>&1 &
    pid=$(pidof "${bin_xray}")
    log Info "xray process (${pid}) started." >>"../log/run.log"
    pid=$(pidof "${bin_box}")
    log Info "sing-box process (${pid}) started." >>"../log/run.log"
  else
    if [[ ! -f "${bin_box}" && ! -f "${bin_xray}" ]]; then
      log Error "Both binaries are missing: $(basename "${bin_box}") and $(basename "${bin_xray}")" >>"../log/run.log"
      toast "Error: Both binaries are missing: $(basename "${bin_box}") and $(basename "${bin_xray}"). Please check your installation."
    elif [[ ! -f "${bin_box}" ]]; then
      log Error "Binary missing: $(basename "${bin_box}")" >>"../log/run.log"
      toast "Error: Missing binary $(basename "${bin_box}"). Please check your installation."
    elif [[ ! -f "${bin_xray}" ]]; then
      log Error "Binary missing: $(basename "${bin_xray}")" >>"../log/run.log"
      toast "Error: Missing binary $(basename "${bin_xray}"). Please check your installation."
    fi
    exit 1
  fi
}

shutdown_cores() {
  pid=$(pidof "${bin_xray}")
  kill "${pid}" >/dev/null 2>&1
  log Info "xray process (${pid}) terminated." >>"../log/run.log"
  pid=$(pidof "${bin_box}")
  kill "${pid}" >/dev/null 2>&1
  log Info "sing-box process (${pid}) terminated." >>"../log/run.log"
  find ".." -type f \( -name "*.log" -o -name "*.list" \) ! -name "run.log" -exec rm -f {} +
}

start_tun() {
  log Info "---welcome---" >"../log/run.log"
  if [[ -n $(pidof "${bin_box}") || -n $(pidof "${bin_xray}") ]]; then
    log Info "Close existing processes"
    stop_tun
    log Info "---restart---" >"../log/run.log"
  fi
  InChange
  launch_cores
  add_cron
  toast "TUNå·²å¯åŠ¨"
  description "ðŸ¤ª" "started"
}

stop_tun() {
  if [[ -z $(pidof "${bin_box}") && -z $(pidof "${bin_xray}") ]]; then
    exit 1
  fi
  log Info "---goodbye---" >"../log/run.log"
  forward -D
  [[ "${dns2tun}" == "enable" ]] && rm_dns_tun
  uidrange del
  rm -f ./tables.tmp
  del_cron
  shutdown_cores
  toast "TUNå·²å…³é—­"
  description "ðŸ¥´" "stopped"
}

start_trp() {
  log Info "---welcome---" >"../log/run.log"
  if [[ -n $(pidof "${bin_box}") || -n $(pidof "${bin_xray}") ]]; then
    log Info "Close existing processes"
    stop_trp
    log Info "---restart---" >"../log/run.log"
  fi
  InChange
  init_uids
  run_add_trp
  run_disable_quic
  launch_cores
  add_cron
  toast "TPå·²å¼€å¯"
  description "ðŸ¤ª" "started"
}

stop_trp() {
  if [[ -z $(pidof "${bin_box}") && -z $(pidof "${bin_xray}") ]]; then
    exit 1
  fi
  log Info "---goodbye---" >"../log/run.log"
  run_del_trp >/dev/null 2>&1
  del_disable_quic
  del_cron
  shutdown_cores
  toast "TPå·²å…³é—­"
  description "ðŸ¥´" "stopped"
}

InChange() {
  if [[ "${network_mode}" == "tproxy" ]]; then
    $yq '.inbounds = [{"type":"tproxy","tag":"tproxy-in","listen":"::","listen_port":2025}]' -i --output-format=json "${inbounds_config_file}"
    tp_port=$(awk -F':' '/"listen_port"/ {gsub(/[^0-9]/, "", $NF); print $NF; exit}' "${box_confs_dir}"/*.json 2>/dev/null)
  elif [[ "${network_mode}" == "tun" ]]; then
    $yq '.inbounds = [{"type":"tun","tag":"tun-in","interface_name":"tun0","mtu":1400,"auto_route":true,"strict_route":true,"endpoint_independent_nat":true,"address":["172.18.0.1/30","fdfe:dcba:9876::1/126"],"stack":"system"}]' -i --output-format=json "${inbounds_config_file}"
  else
    log Warn "Only supports tproxy or tun " > "../log/run.log"
    toast "network_mode Error"
    exit 1
  fi
}

description() {
  local symbol=$1
  local event=$2
  version
  prop_file="${module_dir}/module.prop"
  core_name_box="${bin_box##*/}"
  core_name_xray="${bin_xray##*/}"
  current_time=$(date "+[%m.%d %H:%M]")
  sed -i "/description/c\description=${current_time} ${symbol} ${core_name_box} ${version_box} work with ${core_name_xray} ${version_xray} ${network_mode} ${event}" "${prop_file}"
  log Info "${symbol} ${network_mode} ${event}" >>"../log/run.log"
}

case "$1" in
enable)
  if [[ "${network_mode}" == "tproxy" ]]; then
    start_trp
  else
    start_tun
  fi
  ;;
disable)
  if [[ "${network_mode}" == "tproxy" ]]; then
    stop_trp
  else
    stop_tun
  fi
  ;;
esac

# TTLink.service
