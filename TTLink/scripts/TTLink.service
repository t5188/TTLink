#!/system/bin/sh
cd ${0%/*} # current working directory
source $(pwd)/settings.ini

disable_ipv6() {
  sysctl -w net.ipv4.ip_forward=1
  sysctl -w net.ipv6.conf.all.forwarding=0
  sysctl -w net.ipv6.conf.all.accept_ra=0
  sysctl -w net.ipv6.conf.wlan0.accept_ra=0
  sysctl -w net.ipv6.conf.all.disable_ipv6=1
  sysctl -w net.ipv6.conf.default.disable_ipv6=1
  sysctl -w net.ipv6.conf.wlan0.disable_ipv6=1
}

enable_ipv6() {
  sysctl -w net.ipv4.ip_forward=1
  sysctl -w net.ipv6.conf.all.forwarding=1
  sysctl -w net.ipv6.conf.all.accept_ra=2
  sysctl -w net.ipv6.conf.wlan0.accept_ra=2
  sysctl -w net.ipv6.conf.all.disable_ipv6=0
  sysctl -w net.ipv6.conf.default.disable_ipv6=0
  sysctl -w net.ipv6.conf.wlan0.disable_ipv6=0
}

device_index() {
  local max_retries=10
  local retry_count=0
  index=""
  if [ ! -f "$(pwd)/tables.tmp" ]; then
    device=$(awk -F'"' '/"interface_name"/ {print $4; exit}' ${box_confs_dir}/*.json)
    while [ -z "$index" ] && [ $retry_count -lt $max_retries ]; do
      index=$(ip route show table all | grep -E "default dev ${device} table [0-9]" | head -n 1 | awk '{print $5}')
      if [ -n "$index" ]; then
        break
      fi
      sleep 2
      retry_count=$((retry_count + 1))
    done
    [[ -n "${index}" ]] && echo "${index} ${device}" >$(pwd)/tables.tmp
    [[ -z "${index}" ]] && log Error "Failed to fetch index" >>"$(dirname $(pwd))/log/run.log" && exit 1
  fi
  read index device <"$(pwd)/tables.tmp"
}

ip_rules() {
  device_index
  local action=$1
  ipv4_rules=(
    "iif lo goto 6000 priority 5000"
    "iif ${device} lookup main suppress_prefixlength 0 priority 5010"
    "iif ${device} goto 6000 priority 5020"
    "from 10.0.0.0/8 lookup ${index} priority 5030"
    "from 172.16.0.0/12 lookup ${index} priority 5040"
    "from 192.168.0.0/16 lookup ${index} priority 5050"
    "nop priority 6000"
    "lookup main priority 7000"
  )
  for rule in "${ipv4_rules[@]}"; do
    ip -4 rule "${action}" ${rule}
  done
  ipv6_rules=(
    "iif lo goto 6000 priority 5000"
    "iif ${device} lookup main suppress_prefixlength 0 priority 5010"
    "iif ${device} goto 6000 priority 5020"
    #"from 2001:db8::/32 lookup ${index} priority 5030"
    #"from fc00::/7 lookup ${index} priority 5040"
    #"from fd00::/8 lookup ${index} priority 5050"
    "nop priority 6000"
    "lookup main priority 7000"
  )
  for rule in "${ipv6_rules[@]}"; do
    ip -6 rule "${action}" ${rule}
  done
}

ipt_tun() {
  local iptables=$1
  local action=$2
  if [[ "${action}" == "-I" ]]; then
    ${iptables} -N TUN_FORWARD 2>/dev/null
    ${iptables} -F TUN_FORWARD 2>/dev/null
    ${iptables} "${action}" TUN_FORWARD -i "${device}" -j ACCEPT
    ${iptables} "${action}" TUN_FORWARD -o "${device}" -j ACCEPT
    ${iptables} "${action}" FORWARD -j TUN_FORWARD
  elif [[ "${action}" == "-D" ]]; then
    ${iptables} "${action}" FORWARD -j TUN_FORWARD
    ${iptables} -F TUN_FORWARD 2>/dev/null
    ${iptables} -X TUN_FORWARD 2>/dev/null
  fi
  ${iptables} "${action}" OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${iptables} "${action}" OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${iptables} "${action}" OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
  ${iptables} "${action}" OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
}

dns_tun() {
  local name="DNS2TUN"
  local ip=${1}
  local iptables=${2}
  local action=${3}
  if [[ "${network_mode}" == "tun" ]]; then
    if [[ "${action}" == "-A" ]]; then
      local action1="add"
    elif [[ "${action}" == "-D" ]]; then
      local action1="del"
    fi
    ${ip} rule ${action1} fwmark 53 table ${index} priority 1000
    ${ip} route ${action1} default dev ${device} table ${index}
    if [[ "${action}" != "-D" ]]; then
      ${iptables} -t mangle -N ${name}
      ${iptables} -t mangle -F ${name}
      ${iptables} -t mangle ${action} ${name} -p udp --dport 53 -j MARK --set-mark 53
      ${iptables} -t mangle ${action} ${name} -p tcp --dport 53 -j MARK --set-mark 53
    fi
    ${iptables} -t mangle ${action} OUTPUT -j ${name}
    ${iptables} -t mangle ${action} PREROUTING -j ${name}
    if [[ "${action}" == "-D" ]]; then
      ${iptables} -t mangle -F ${name}
      ${iptables} -t mangle -X ${name}
    fi
  else
    return
  fi
}

exec_dns_tun() {
  dns_tun "ip -4" "iptables" "-A"
  dns_tun "ip -6" "ip6tables" "-A"
}

rm_dns_tun() {
  dns_tun "ip -4" "iptables" "-D"
  dns_tun "ip -6" "ip6tables" "-D"
}

forward() {
  local action=$1
  sysctl -w net.ipv4.ip_forward=1
  sysctl -w net.ipv4.conf.default.rp_filter=2
  sysctl -w net.ipv4.conf.all.rp_filter=2
  if [[ "${action}" == "-I" ]]; then
    enable_ipv6
    ip_rules "add"
  elif [[ "${action}" == "-D" ]]; then
    ip_rules "del"
  fi
  ipt_tun "iptables" "${action}"
  ipt_tun "ip6tables" "${action}"
}

uidrange() {
  local action=${1}
  stdout2array=()

  if [[ "${proxy_mode}" == "whitelist" ]] && [[ ${#package_list[@]} -gt 0 ]]; then
    stdout2array=($(init_uidrange))
    for whiteapp in "${stdout2array[@]}"; do
      ip -4 rule ${action} from all uidrange ${whiteapp} priority 9000 goto 9010
      ip -6 rule ${action} from all uidrange ${whiteapp} priority 9000 goto 9010
    done

  elif [[ "${proxy_mode}" == "blacklist" ]] && [[ ${#package_list[@]} -gt 0 ]]; then
    init_uids
    uids+=("${box_user}" "${xray_user}")
    uids=($(printf "%s\n" "${uids[@]}" | sort -n | uniq))
    for blackapp in "${uids[@]}"; do
      ip -4 rule ${action} from all uidrange ${blackapp}-${blackapp} priority 9000 goto 9010
      ip -6 rule ${action} from all uidrange ${blackapp}-${blackapp} priority 9000 goto 9010
    done

  elif [[ ${#package_list[@]} -eq 0 ]]; then
    uids=("${box_user}" "${xray_user}")
    for users in "${uids[@]}"; do
      ip -4 rule ${action} from all uidrange ${users}-${users} priority 9000 goto 9010
      ip -6 rule ${action} from all uidrange ${users}-${users} priority 9000 goto 9010
    done

  else
    return
  fi
}

add_trp() {
# Policy routing: fwmark -> table ${table}, then redirect to local (lo) for TPROXY
  ${1} rule add fwmark "${fwmark}" table ${table} priority 1000
  ${1} route add local default dev lo table ${table}
# Initialize custom chains (EXTERNAL, LOCAL)
  ${2} -t mangle -N ${3}_EXTERNAL
  ${2} -t mangle -F ${3}_EXTERNAL
  ${2} -t mangle -N ${3}_LOCAL
  ${2} -t mangle -F ${3}_LOCAL
  ${2} -t mangle -N ${3}_BLOCK_LOOPBACK
  ${2} -t mangle -F ${3}_BLOCK_LOOPBACK
# Exclude Xray process traffic (prevent proxy loop)
  ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${box_user} --gid-owner ${box_group} -j RETURN
  ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${xray_user} --gid-owner ${xray_group} -j RETURN
  for proto in udp tcp; do
    # Mark local DNS (53) traffic for proxy routing
    ${2} -t mangle -A ${3}_LOCAL -p ${proto} --dport 53 -j MARK --set-xmark ${fwmark}
    # Redirect external DNS (53) traffic to TPROXY port with mark
    ${2} -t mangle -A ${3}_EXTERNAL -p ${proto} --dport 53 -j TPROXY --on-port ${tp_port} --tproxy-mark ${fwmark}
  done
# Bypass specified subnets (do not route them into proxy)
  ${2} -t mangle -A ${3}_EXTERNAL -j ${3}_BLOCK_LOOPBACK
  ${2} -t mangle -A ${3}_LOCAL -j ${3}_BLOCK_LOOPBACK
  for subnet in ${4}; do
    ${2} -t mangle -A ${3}_EXTERNAL -d ${subnet} -j RETURN
    ${2} -t mangle -A ${3}_LOCAL -d ${subnet} -j RETURN
  done
# Route traffic into the tproxy
  for proto in udp tcp; do
    ${2} -t mangle -A ${3}_EXTERNAL -p ${proto} -j TPROXY --on-port "${tp_port}" --tproxy-mark "${fwmark}"
  done
# Mark traffic from specified system UIDs for proxy routing
  if [[ -n "${AIDs}" ]]; then
    for AID in ${AIDs[@]}; do
      ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${AID} -p tcp -j MARK --set-xmark ${fwmark}
      ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${AID} -p udp -j MARK --set-xmark ${fwmark}
    done
  fi
# Blacklist mode: exclude specified UIDs (except DNS), all others go through proxy
# Whitelist mode: only specified UIDs go through proxy, if none specified then all
  case "${proxy_mode}" in
  "blacklist")
    if [[ ${#uids[@]} -gt 0 ]]; then
      for appid in ${uids[*]}; do
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p tcp ! --dport 53 -j RETURN
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p udp ! --dport 53 -j RETURN
      done
      ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    else
      ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    fi
    ;;
  "whitelist")
    if [[ ${#uids[@]} -gt 0 ]]; then
      for appid in ${uids[*]}; do
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p tcp -j MARK --set-xmark ${fwmark}
        ${2} -t mangle -A ${3}_LOCAL -m owner --uid-owner ${appid} -p udp -j MARK --set-xmark ${fwmark}
      done
    else
      ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    fi
    ;;
  *)
    ${2} -t mangle -A ${3}_LOCAL -j MARK --set-xmark ${fwmark}
    toast "GLOBAL PROXY, CHECK PROXY_MODE"
    ;;
  esac
# Attach custom chains: EXTERNAL -> PREROUTING, LOCAL -> OUTPUT
  ${2} -t mangle -A PREROUTING -j ${3}_EXTERNAL
  ${2} -t mangle -A OUTPUT -j ${3}_LOCAL
}

del_trp() {
  ${1} rule del fwmark "${fwmark}" table ${table} priority 1000
  ${1} route del local default dev lo table ${table}
  ${1} route flush table ${table}
  ${2} -t mangle -D PREROUTING -j ${3}_EXTERNAL
  ${2} -t mangle -D OUTPUT -j ${3}_LOCAL
  ${2} -t mangle -F ${3}_EXTERNAL
  ${2} -t mangle -F ${3}_LOCAL
  ${2} -t mangle -F ${3}_BLOCK_LOOPBACK
  ${2} -t mangle -X ${3}_EXTERNAL
  ${2} -t mangle -X ${3}_LOCAL
  ${2} -t mangle -X ${3}_BLOCK_LOOPBACK
}

run_add_trp() {
  log Info "tp_port: ${tp_port}" >>"$(dirname $(pwd))/log/run.log"
  add_trp "ip -4" "${IPV}" "${chain_name}4" "${intranet4[*]}"
  add_trp "ip -6" "${IP6V}" "${chain_name}6" "${intranet6[*]}"
}

run_del_trp() {
  del_trp "ip -4" "${IPV}" "${chain_name}4"
  del_trp "ip -6" "${IP6V}" "${chain_name}6"
}

disable_quic() {
  ${1} ${2} OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${1} ${2} OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${box_user} ! --gid-owner ${box_group} -j REJECT
  ${1} ${2} OUTPUT -p udp --dport 443 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
  ${1} ${2} OUTPUT -p udp --dport 80 -m owner ! --uid-owner ${xray_user} ! --gid-owner ${xray_group} -j REJECT
}

run_disable_quic() {
  if [[ "${quic}" == "disable" ]]; then
    disable_quic "${IPV}" "-I"
    disable_quic "${IP6V}" "-I"
  fi
}

del_disable_quic() {
  if [[ "${quic}" == "disable" ]]; then
    disable_quic "${IPV}" "-D"
    disable_quic "${IP6V}" "-D"
  fi
}

ownership() {
  chmod 755 ${bin_box} ${bin_xray}
  chown root:net_admin ${bin_box} ${bin_xray}
  chmod o+rw ${public_log_dir}
  find ".." -type f -name "*.log" ! -name "run.log" -exec rm -f {} + 2>/dev/null
}

launch_cores() {
  ulimit -SHn 1000000
  ownership
  init_outbound
  [ "${ENABLE_THIRD_CORE}" -eq 0 ] && ech-tunnel
  pid_3core=$!
  if [[ -f "${bin_box}" && -f "${bin_xray}" ]]; then
    nohup busybox setuidgid ${box_user}:${box_group} ${bin_box} run -C ${box_confs_dir} -D $(dirname $(pwd))/binary/ >/dev/null 2>&1 &
    pid_box=$!
    if [[ "${network_mode}" == "tun" ]]; then
      forward -I
      uidrange add
      [[ "${dns2tun}" == "enable" ]] && exec_dns_tun
    fi
    nohup busybox setuidgid ${xray_user}:${xray_group} ${bin_xray} run -confdir ${xray_confx_dir} >/dev/null 2>&1 &
    pid_xray=$!

    echo "${bin_box##*/}:${pid_box}" >"$(dirname "$(pwd)")/log/pid.txt"
    echo "${bin_xray##*/}:${pid_xray}" >>"$(dirname "$(pwd)")/log/pid.txt"
    [ "${ENABLE_THIRD_CORE}" -eq 0 ] && echo "${bin_3core##*/}:${pid_3core}" >>"$(dirname "$(pwd)")/log/pid.txt"
    
  else
    if [[ ! -f "${bin_box}" && ! -f "${bin_xray}" ]]; then
      toast "Error: Both binaries are missing: $(basename "${bin_box}") and $(basename "${bin_xray}"). Please check your installation."
    elif [[ ! -f "${bin_box}" ]]; then
      toast "Error: Missing binary $(basename "${bin_box}"). Please check your installation."
    elif [[ ! -f "${bin_xray}" ]]; then
      toast "Error: Missing binary $(basename "${bin_xray}"). Please check your installation."
    fi
    exit 1
  fi
}

shutdown_cores() {
  while IFS=: read name pid; do
    kill -9 "$pid"
  done < "$(dirname "$(pwd)")/log/pid.txt"
  find ".." -type f \( -name "*.log" -o -name "*.txt" -o -name "*.list" \) ! -name "run.log" -exec rm -f {} +
}

start_tun() {
  log Info "---welcome---" >"$(dirname $(pwd))/log/run.log"
  if [[ -n $(pidof "${bin_box}") || -n $(pidof "${bin_xray}") ]]; then
    log Info "Close existing processes"
    stop_tun
    log Info "---restart---" >"$(dirname $(pwd))/log/run.log"
  fi
  InChange
  launch_cores
  add_cron
  toast "TUNå·²å¯åŠ¨"
  description "ðŸ¤ª" "started"
}

stop_tun() {
  if [[ -z $(pidof "${bin_box}") && -z $(pidof "${bin_xray}") ]]; then
    exit 1
  fi
  log Info "---goodbye---" >"$(dirname $(pwd))/log/run.log"
  forward -D
  [[ "${dns2tun}" == "enable" ]] && rm_dns_tun
  uidrange del
  rm -f $(pwd)/tables.tmp
  del_cron
  shutdown_cores
  toast "TUNå·²å…³é—­"
  description "ðŸ¥´" "stopped"
}

start_trp() {
  log Info "---welcome---" >"$(dirname $(pwd))/log/run.log"
  if [[ -n $(pidof "${bin_box}") || -n $(pidof "${bin_xray}") ]]; then
    log Info "Close existing processes"
    stop_trp
    log Info "---restart---" >"$(dirname $(pwd))/log/run.log"
  fi
  InChange
  enable_ipv6
  init_uids
  run_add_trp
  run_disable_quic
  launch_cores
  add_cron
  toast "TPå·²å¼€å¯"
  description "ðŸ¤ª" "started"
}

stop_trp() {
  if [[ -z $(pidof "${bin_box}") && -z $(pidof "${bin_xray}") ]]; then
    exit 1
  fi
  log Info "---goodbye---" >"$(dirname $(pwd))/log/run.log"
  run_del_trp >/dev/null 2>&1
  del_disable_quic
  del_cron
  shutdown_cores
  toast "TPå·²å…³é—­"
  description "ðŸ¥´" "stopped"
}

case "$1" in
enable)
  if [[ "${network_mode}" == "tproxy" ]]; then
    start_trp
  else
    start_tun
  fi
  ;;
disable)
  if [[ "${network_mode}" == "tproxy" ]]; then
    stop_trp
  else
    stop_tun
  fi
  ;;
esac

# TTLink.service Last edited: 2025.12.05
